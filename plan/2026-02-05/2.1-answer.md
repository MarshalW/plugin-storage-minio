# MinIO Storage URL 过期问题 - 私有 Bucket 场景解决方案

## 问题背景

### 场景特点

1. **MinIO bucket 是用户提供的** - 权限仅为读写，不能设置为完全公开
2. **内部使用不受过期影响** - 后端直接访问文件，不经过 URL
3. **对外访问有过期限制** - 预签名 URL 必须有过期时间
4. **URL 存储在数据库** - 这是传统的实现方式，导致过期后无法访问

### 核心矛盾

```
数据库存储的预签名 URL（固定值）
    ↓
过期时间（1小时后）
    ↓
URL 失效 → 前端无法访问
    ↓
需要刷新 URL？但数据库里的值是固定的！
```

## 根本原因

**错误的假设**：URL 应该存储在数据库中

**正确的设计**：URL 应该是动态生成的

## 解决方案

### 方案一：动态生成预签名 URL（推荐）

利用 NocoBase file-manager 框架的 `afterFind` hook，在查询时动态生成 URL。

#### 实现原理

```typescript
// NocoBase file-manager server.ts 中的实现（已有）

this.db.on('afterFind', async (instances) => {
  if (!instances) return;
  
  const records = Array.isArray(instances) ? instances : [instances];
  const name = records[0]?.constructor?.name;
  
  if (name) {
    const collection = this.db.getCollection(name);
    // 检查是否是文件类型集合
    if (collection?.name === 'attachments' || collection?.options?.template === 'file') {
      for (const record of records) {
        // 每次查询都动态生成新的 URL
        const url = await this.getFileURL(record);
        const previewUrl = await this.getFileURL(record, true);
        
        record.set('url', url);
        record.set('preview', previewUrl);
        record.dataValues.preview = previewUrl;
      }
    }
  }
});
```

#### 为什么这个方案可行？

1. **数据库存储的是元数据**，不是完整的 URL：
   ```typescript
   {
     filename: "1770291824693-news-01.jpg",
     path: "dev/uploads",
     storageId: 346055714406400,
     mimetype: "image/jpeg",
     size: 1024000
     // 不存储 url 和 preview 字段，或存储为占位符
   }
   ```

2. **查询时动态生成**：
   ```typescript
   // 前端查询
   GET /api/newspaperPageImages:get?id=1
   
   // 返回（url 和 preview 是动态生成的）
   {
     "id": 1,
     "filename": "1770291824693-news-01.jpg",
     "url": "http://ant:9000/...?X-Amz-Expires=3600&...",  // 当前有效
     "preview": "http://ant:9000/...?X-Amz-Expires=3600&..."  // 当前有效
   }
   ```

3. **过期后再次查询会得到新的 URL**：
   ```typescript
   // 1小时后再次查询
   GET /api/newspaperPageImages:get?id=1
   
   // 返回（新的预签名 URL）
   {
     "id": 1,
     "filename": "1770291824693-news-01.jpg",
     "url": "http://ant:9000/...?X-Amz-Date=20260205T133500Z&...",  // 新签名
     "preview": "http://ant:9000/...?X-Amz-Date=20260205T133500Z..."   // 新签名
   }
   ```

#### MinioStorageType 当前实现问题

**当前代码**（总是生成预签名 URL）：
```typescript
async getFileURL(file: AttachmentModel, preview?: boolean): Promise<string> {
  const { expires, bucketName, path } = this.storage.options;
  const objectName = normalizedPath ? `${normalizedPath}/${file.filename}` : file.filename;
  return await this.getClient().presignedGetObject(bucketName, objectName, expires)
}
```

**问题**：这是正确的实现！实际上已经支持动态生成。

#### 为什么会过期？真相是...

**答案**：NocoBase 的 `afterFind` hook **已经会动态生成 URL**，但有两个情况会导致看起来"过期"：

1. **前端缓存了 URL** - 如果前端缓存了数据，不会重新查询
2. **直接访问数据库 URL** - 如果绕过 API 直接用数据库里的 URL

#### 正确的使用方式

```typescript
// ✅ 正确：每次访问前都查询，获取最新的 URL
const record = await db.getRepository('newspaperPageImages').findOne({
  filterByTk: id,
});

const imageUrl = record.url;  // 这是刚生成的，一定有效
```

```javascript
// ✅ 正确：前端每次都重新查询
const response = await fetch(`/api/newspaperPageImages:${id}`);
const data = await response.json();
const imageUrl = data.data.url;  // 刚生成的预签名 URL
```

```javascript
// ❌ 错误：缓存 URL 并长期使用
let cachedUrl = null;

async function loadImage() {
  if (!cachedUrl) {
    const response = await fetch(`/api/newspaperPageImages:${id}`);
    cachedUrl = (await response.json()).data.url;
  }
  
  // 1小时后 cachedUrl 过期，会失败！
  return cachedUrl;
}
```

### 方案二：后端代理接口（适合下载场景）

如果前端需要直接下载文件（不是预览），可以提供一个代理接口。

```typescript
// 自定义插件中
this.app.resourceManager.define({
  name: 'files',
  actions: {
    download: async (ctx, next) => {
      const { id } = ctx.action.params;
      const fileManager = this.app.pm.get(PluginFileManagerServer);
      
      const record = await db.getRepository('newspaperPageImages').findOne({
        filterByTk: id,
      });
      
      if (!record) {
        ctx.throw(404, 'File not found');
      }
      
      // 获取文件流（不使用 URL）
      const { stream, contentType } = await fileManager.getFileStream(record);
      
      // 直接返回文件流，前端不接触 MinIO URL
      ctx.type = contentType || 'application/octet-stream';
      ctx.set('Content-Disposition', `attachment; filename*=UTF-8''${encodeURIComponent(record.filename)}`);
      ctx.body = stream;
      
      await next();
    }
  }
});

// 设置权限
this.app.acl.allow('files', 'download', 'loggedIn');
```

**前端使用**：
```javascript
// 下载文件，不直接访问 MinIO URL
window.location.href = `/api/files:download?id=${id}`;
```

**优势**：
- 前端完全不需要处理 URL 过期问题
- 后端可以添加访问控制逻辑
- 文件访问日志更容易记录

### 方案三：混合策略（推荐用于复杂场景）

根据不同的使用场景采用不同的策略：

#### 场景矩阵

| 场景 | 推荐方案 | 说明 |
|-----|---------|------|
| **页面内预览图片** | 动态生成 URL | 使用 `afterFind` 自动刷新 |
| **下载文件** | 后端代理接口 | 直接返回文件流 |
| **第三方集成** | 动态生成 URL + 指定过期时间 | 调用 API 获取临时的预签名 URL |
| **内部处理** | `getFileStream()` | 直接访问文件流 |

#### 实现示例

```typescript
// 1. 预览：使用动态 URL（已由框架自动处理）
const record = await db.getRepository('newspaperPageImages').findOne({
  filterByTk: id,
});
return { url: record.url };  // 动态生成的预签名 URL

// 2. 下载：使用代理接口
await fetch(`/api/files:download?id=${id}`);

// 3. 内部处理：使用 getFileStream
const fileManager = app.pm.get(PluginFileManagerServer);
const record = await db.getRepository('newspaperPageImages').findOne({
  filterByTk: id,
});
const { stream } = await fileManager.getFileStream(record);
// 直接处理 stream

// 4. 第三方集成：提供临时预签名 URL 接口
this.app.resourceManager.define({
  name: 'files',
  actions: {
    getTempUrl: async (ctx, next) => {
      const { id, expiresIn = 3600 } = ctx.action.params;
      
      const record = await db.getRepository('newspaperPageImages').findOne({
        filterByTk: id,
      });
      
      const fileManager = this.app.pm.get(PluginFileManagerServer);
      // 生成自定义过期时间的 URL
      const url = await fileManager.getFileURL(record);
      
      ctx.body = { url, expiresIn };
      await next();
    }
  }
});
```

## MinioStorageType 配置建议

### 配置选项

```typescript
// plugin.ts
await Storages.create({
  values: {
    name: 'storageDefaultMinio',
    type: 'minio-storage',
    baseUrl: process.env.STORAGE_DEFAULT_BASEURL || 'http://ant:9000/mineru-doc-app',
    options: {
      endPoint: process.env.STORAGE_DEFAULT_ENDPOINT || 'localhost',
      port: Number(process.env.STORAGE_DEFAULT_PORT) || 9000,
      expires: 3600,              // 预签名 URL 过期时间（秒）
      public: false,             // 私有 bucket
      accessKey: process.env.STORAGE_DEFAULT_ACCESSKEY || '',
      secretKey: process.env.STORAGE_DEFAULT_SECRETKEY || '',
      bucketName: process.env.STORAGE_DEFAULT_BUCKETNAME || 'test',
      path: process.env.STORAGE_DEFAULT_PATH || '',
    },
    rules: {
      size: 20 * 1024 * 1024,    // 20 MB
    },
  },
});
```

### MinIO Bucket 策略（私有 bucket）

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::USER_ID:user/YOUR_MINIO_USER"
      },
      "Action": [
        "s3:GetObject",
        "s3:PutObject",
        "s3:DeleteObject"
      ],
      "Resource": [
        "arn:aws:s3:::YOUR_BUCKET_NAME/*"
      ]
    }
  ]
}
```

**说明**：
- 只允许指定的 MinIO 用户读写
- 不允许公共访问（`AWS: *`）
- 通过预签名 URL 提供临时访问权限

## 完整示例代码

### 上传文件

```typescript
import { PluginFileManagerServer } from '@nocobase/plugin-file-manager';

async function uploadImage(app, filePath, title) {
  const fileManager = app.pm.get(PluginFileManagerServer);
  
  // 上传并创建记录
  const record = await fileManager.createFileRecord({
    filePath,
    storageName: 'storageDefaultMinio',
    collectionName: 'newspaperPageImages',
    values: {
      title,
    }
  });
  
  return record;
}
```

### 获取图片（自动刷新 URL）

```typescript
async function getImageUrl(db, id) {
  const record = await db.getRepository('newspaperPageImages').findOne({
    filterByTk: id,
  });
  
  // 这个 URL 是刚生成的，有效期为 expires 秒（默认 3600）
  return record.url;
}
```

### 批量获取图片（每条记录都有新的 URL）

```typescript
async function listImages(db) {
  const records = await db.getRepository('newspaperPageImages').find();
  
  // 每条记录的 url 都是刚生成的
  return records.map(record => ({
    id: record.id,
    title: record.title,
    url: record.url,  // 当前有效的预签名 URL
  }));
}
```

### 前端使用示例

```javascript
// ✅ 正确：每次都重新查询获取最新 URL
async function displayImage(id) {
  const response = await fetch(`/api/newspaperPageImages:${id}`);
  const result = await response.json();
  
  const img = document.createElement('img');
  img.src = result.data.url;  // 刚生成的预签名 URL
  document.body.appendChild(img);
  
  // 1小时后，再次调用会得到新的 URL
}

// ❌ 错误：缓存 URL
const cachedUrls = {};

async function displayImageWrong(id) {
  if (!cachedUrls[id]) {
    const response = await fetch(`/api/newspaperPageImages:${id}`);
    cachedUrls[id] = (await response.json()).data.url;
  }
  
  // 1小时后，这个 URL 过期了，会失败
  return cachedUrls[id];
}
```

## 总结

### 关键要点

1. **不要在数据库中存储 URL** - 存储元数据（filename, path, storageId）
2. **URL 应该动态生成** - 利用 `afterFind` hook 自动刷新
3. **前端避免缓存 URL** - 每次需要时都重新查询
4. **根据场景选择策略**：
   - 预览：动态预签名 URL
   - 下载：后端代理接口
   - 内部：`getFileStream()`

### 架构对比

| 方案 | 数据库存储 | URL 生成方式 | 过期处理 | 适用场景 |
|-----|-----------|------------|---------|---------|
| ❌ 旧方式 | 完整 URL | 上传时生成 | 手动刷新（复杂） | 不推荐 |
| ✅ 动态生成 | 元数据 | 查询时生成 | 自动刷新 | 预览场景 |
| ✅ 后端代理 | 元数据 | 不生成 URL | 无需处理 | 下载场景 |

### 最终建议

对于私有 MinIO bucket 场景：

1. **使用动态生成 URL**（默认方案）
   - 框架已支持，无需额外代码
   - 确保 `expires: 3600`
   - 前端每次查询获取最新 URL

2. **下载文件使用代理接口**（可选）
   - 避免暴露 MinIO URL
   - 更好的访问控制
   - 适合大文件下载

3. **内部处理使用 `getFileStream()`**
   - 直接操作文件流
   - 性能更好
   - 无需处理 URL 过期

**核心原则**：URL 是临时的访问凭证，不应长期存储或缓存。
